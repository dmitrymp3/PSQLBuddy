# BackupBuddy - резервное копирование и восстановление PostgreSQL
## Введение
### Какие задачи решались
1. Выполнение резервного копирования отдельных баз данных на сервере БД
2. Выгрузка каждой базы по отдельности в S3 хранилище
3. Очистка хранилища от старых бэкапов
4. Восстановление базы в специально созданную архивную с помощью бота
5. Интерфейс управления восстановлением из бэкапа

### История создания
Когда-то давно, еще сидя на виртуалках, я сделал чистый shell скрипт, который выполняет плюс-минус те же самые задачи. Спустя несколько лет, когда возникла необходимость снова сменить сервер, мне захотелось переписать это все на python и нормальные библиотеки, чтобы по-человечески запустить это все в маленьком уютном окружении и добавить возможность пользователю восстанавливать базы в архив без моего участия.Изначально я реализовал две утилиты - одну для создания бэкапов, а другую для разворачивания бэкапа в архив. Но в итоге слил их в одно целое, сделав возможным запуск утилиты с аргументами --backup & --restore. О них детально ниже.

### Минусы pg_dump, pg_dumpall, pg_restore
При использовании pg_dump для регулярного резервного копирования каждой базы данных, необходимо создавать отдельные задачи в cron. Этот подход требует значительных усилий по управлению, особенно если в системе имеется множество баз данных. Каждая задача требует указания множества атрибутов, таких как форматы вывода, параметры подключения и уровни сжатия, что увеличивает вероятность ошибок и усложняет администрирование.
Проблема усугубляется при использовании утилиты pg_restore, которая требует предварительной очистки базы данных перед восстановлением. Этот процесс может быть трудоемким и рискованным, особенно если работаете в боевом окружении. Кроме того, для успешного восстановления необходимо точно знать набор атрибутов, использованных при резервном копировании.
И, конечно же, речи не идет об автоматической выгрузке файлов на внешнее хранилище и обеспечении ротации. 

### Плюсы BackupBuddy
BackupBuddy - более эффективный и удобный подход к резервному копированию баз данных PostgreSQL. Внутри создается простой конфиг с настройками целевого хранилища и  баз данных для резервного копирования, и количество хранимых бэкапов.
Утилита BackupBuddy организует выгрузку данных в S3-хранилище, а также удаление файлов на сервере после успешного завершения операции. Предусмотрены механизмы очистки S3-хранилища в соответствии с заранее определенными правилами хранения резервных копий. 

# Установка и запуск
### Предварительная подготовка
Запускать BackupBuddy будем из под пользователя postgres, который по умолчанию присутствует в системе с установленным postgresql. Если у пользователя postgres нету домашней директории, рекомендую ее для него создать. В дальнейшем будем считать, что у нас все лежит в **/home/postgres/BackupBuddy**
Переходим в целевую папку и копируем все из репозитория
```shell
cd /home/postgres/
git clone https://github.com/dmitrymp3/backup_and_restore.git
```
Создаем директорию для временных файлов (она же temp_path в конфиге)
```
mkdir temp
```
После заполнения конфига можем приступать к созданию  и активации окружения
```
python -m venv venv
source venv/bin/activate
```
После чего мы должны увидеть в начале строки (venv)
Если предыдущий шаг прошел успешно и мы видим, что мы находимся в окружении (venv), то можем установить в это окружение зависимости для работы программы. 
```
pip install -r requirements.txt
```

## Регистрация в timeweb
Если вы еще не зарегистрированы в timeweb, то можете сделать это по моей [реферальной ссылочке](https://timeweb.cloud/?i=104933). Буду очень благодарен :)
Но если вы зарегистрируетесь напрямую, то магия никуда не исчезнет, все будет работать точно так же, просто таймвеб не угостит меня кофем :)

После регистрации создаем новое S3 хранилище.
![alt text](https://github.com/dmitrymp3/readme_files/blob/main/824047be70946de17291cfcc0467a24f.png?raw=true)

Думаю, вы прекрасно справитесь с созданием нового бакета и увидите Примерно такую картину:
![alt text](https://github.com/dmitrymp3/readme_files/blob/main/25e1e150988ea511e9db7be6a9752a61.png?raw=true)

Отсюда нас интересует три вещи - **S3 Access Key**, **S3 Secret Access Key** и название бакета (339e534d-my_test_bucket на скриншоте выше). Вы без проблем сопоставите их тремя полями в конфиге (он же boto_config).

### Заполнение конфига
Переименовываем конфиг в папке conf
```shell
mv conf/config.sample conf/config.py
```

**databases** - список из объектов типа DatabaseForBackup. Сюда мы запихиваем названия баз данных, которые мы хотим резервировать. Объект DatabaseForBackup принимает в себя один обязательный аргумент - название базы. И второй необязательный - словарь с количеством хранимых бэкапов. Если словарь не передать, будут установлены значения по умолчанию:
- 4 ежедневных
- 4 еженедельных
- 4 ежемесячных
- 999 годовых

Пример добавленных баз данных:
```python
databases = [
        # Не заполнили ничего. Все будет по умолчанию
        DatabaseForBackup('buh2_db'),

        # Здесь указали все возможные значения                 
        DatabaseForBackup('spartak_db', {
              'DAILY': 10,
              'WEEKLY': 15,
              'MONTHLY': 4,
              'YEARLY': 5
        }),

        # Переопределили только количество еженедельных бэкапов. Остальные по умолчанию
        DatabaseForBackup('zup3', {'WEEKLY': 10}),           
    ]
```


**boto_config** - по умолчанию настроенный на работу с хранилищем s3 в timeweb, но можно настроить на любое другое s3 хранилище. Минимальный набор данных - aws_access_key_id (логин), aws_secret_access_key (пароль) и s3_bucket (папка). 
**bot_token** - токен вашего бота, которым вы будете управлять восстановлением резервных копий
**tg_admins** - ID пользователей, которым бот будет вообще отвечать. 
**temp_path** - директория, куда будут складываться временные файлы (скачанные и созданные бэкапы). Если вы не хотите трогать основной диск - можно ее поменять, но будьте внимательны, у пользователя postgres должны быть права на чтение и запись в эту папку.

### Донастройка
Присваиваем всем файлам владельца - postgres
```shell
chown -R postgres:postgres /home/postgres
```
Меняем пользователя
```shell
su postgres
```
## Запуск
### Запуск в режиме --backup
В данном режиме программа запускается единоразово, а следовательно - нам надо добавить задачу в cron (из под пользователя postgres)
Редактируем crontab
```shell
crontab -e
```
Добавляем туда строчку
```
0 4 * * * cd /home/postgres/PgBackupMaster/ && venv/bin/python3 main.py --backup
```
Что будет означать: Каждый день в 4.00 переходим в папку с программой и запускаем из интерпретатора в окружении программу с аргументом backup

### Запуск в режиме --restore
В режиме restore программа должна быть постоянно запущена, и лучший способ это обеспечить - запустить ее как сервис. Для этого можно воспользоваться файлом **PostgresBackupBot.service**. Для начала надо проверить, что внутри файла. Там должны быть правильно прописаны пути. Затем делаем софтлинк этого файла в папку /etc/systemd/system/ и обновляем список сервисов
```
ln -s /home/backup/PostgresBackupBot/PostgresBackupBot.service PostgresBackupBot.service
systemctl daemon-reload
```
Затем активируем службу и запускаем ее
```
systemctl enable PostgresBackupBot.service
systemctl start PostgresBackupBot.service
```
Проверяем успешность запуска командой
```
systemctl status PostgresBackupBot.service
```
Если что-то не получается с запуском сервиса, всегда можно запустить скрипт вручную:
```
venv/bin/python3 main.py --restore
```

## Технические детали
### Настройка на другие s3-хранилища
Полный набор настроек описан в классе BotoConfig в файле conf/config_classes.py. Можно как задать их напрямую там (значения по умолчанию), так и переопределить в конфиге.

### Лексикон бота
На момент релиза мне было лень редактировать фразы бота, да и вообще, как мне кажется, что "Витя" - хороший собирательный образ для бухгалтера :)В любом случае все фразочки захардкожены в файле bot/bot_init.py, много знаний, чтобы их подправить не нужно. 

### Изменение количества хранимых бэкапов по умолчанию
Можно поменять в классе **DatabaseForBackup** файла conf/config_classes.py

## Набор библиотек
python, boto3, subprocess

# Заключение
## Итоги внедрения утилит 
Установив экземпляр программы на свою базу данных, я получаю теперь отдельные бэкапы каждый день, их ротацию и хранение в дешевом хранилище. По состоянию на конец 24го года мы платим 1200 рублей за 500 гигабайт, что гораздо адекватнее покупки дополнительного диска на VDS. Там 500 гигабайт обойдется в 5000 рублей ежемесячно и подключить больше 500 гигабайт я возможности не видел. 
Мой бухгалтер, в свою очередь, может без проблем восстановить базу данных за определенный период и посмотреть, что там было (например, если на складе обнаружили недостачу, а в базе информация отсутствует). 

## Планы по дальнейшему улучшению
- Сделать блокировку работы с базой если уже запущен один процесс
- Добавить периодичность создания бэкапов (эту базу бэкапим только по понедельникам).

## Благодарности
Нажмете звездочку - буду счастлив. 
